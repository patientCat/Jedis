# Jedis
自己打算一遍学习Redis，一边写一个自己的Jedis出来。

## 0.1. Reactor
首先完成Reactor的部分
完成了简单日志库

## 0.2. 简单的Redis
完成了Redis的基本功能
主要是JObject的构建，想到了使用boost::any来进行多态

## 0.3. Telnet的命令解析
因为只是本地学习，所以采用telnet协议。
完成了了TelnetDecode，注意可以学习muduo，单独加一个回调层出来。这样回调给上层的就是vector<string>了，已经是做好字符串分割的了。

## 0.4. 简单数据结构和命令解析
完成了JString，JList的俩个数据结构的3个基本命令的实现
因为本身不是为了性能考虑，所以直接使用了STL。

### 命令解析
命令解析的合法性，对于redis来说，每个命令有俩种类型，有的命令参数是只能允许固定个参数。有的命令则是至少需要多少个参数。
验证这样命令的合法性。比如set来说，只允许3个参数。我们就设置其为3。又因为其会修改数据库，所以其属性是写命令。
对于lpush来说，则是至少需要3个命令。那么我们就可以设置其为-3。

### 命令表的分发
经典的hash表应用。根据命令寻找其属性，先验证其合法性。然后再得到其回调函数进行利用。

## 0.5. 错误处理
完善了错误处理。交互更加人性化。

## 0.6 订阅发布和事务的实现
订阅发布机制实际上就是典型的生产者和消费者模式。实现起来也比较简单。
事务的实现主要是依赖一个队列。同时涉及事务回滚的问题。需要dirtykey的设置。主要按照Redis设计与实现部分实现。


### Topic/Channel
在redis里面，叫了Channel但是在Kafka中实际上是叫Topic的。其本质上是差不多。下面谈实现。
首先设计一个topic_name-topic的hash映射。每个topic存放的是connection的set。这样就完成了订阅结构的存取。然后在对应的命令表中实现
对应命令。
### 事务
事务实现起来也比较简单，就是不去立即执行命令，而是去用一个队列收集命令。EXEC后，才会一次性执行所有命令。
