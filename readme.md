# Jedis
自己打算一遍学习Redis，一边写一个自己的Jedis出来。

## 0.1. Reactor
首先完成Reactor的部分
完成了简单日志库

> 这部分都是之前学习muduo已经写好了的。

## 0.2. 简单的Redis
完成了Redis的基本功能
主要是JObject的构建，想到了使用boost::any来进行多态

> any要求对象可copy。
> 如果对象不可拷贝，可以加一层shared_ptr来解决

## 0.3. Telnet的命令解析
因为只是本地学习，所以采用telnet协议。
完成了了TelnetDecode，注意可以学习muduo，单独加一个回调层出来。这样回调给上层的就是vector<string>了，已经是做好字符串分割的了。

## 0.4. 简单数据结构和命令解析
完成了JString，JList的俩个数据结构的3个基本命令的实现
因为本身不是为了性能考虑，所以直接使用了STL。

### 命令校验
命令解析的合法性，对于redis来说，每个命令有俩种类型，有的命令参数是只能允许固定个参数。有的命令则是至少需要多少个参数。
验证这样命令的合法性。比如set来说，只允许3个参数。我们就设置其为3。又因为其会修改数据库，所以其属性是写命令。
对于lpush来说，则是至少需要3个命令。那么我们就可以设置其为-3。

### 命令表的分发
经典的hash表应用。根据命令寻找其属性，先验证其合法性。然后再得到其回调函数进行利用。

> 大概思路如下
> 1. CommandTable初始化命令表。根据cmd，设置对应的handler。以及其他属性。

## 0.5. 错误处理
完善了错误处理。交互更加人性化。

> TODO：使用异常替代错误码。之前总是对使用错误码还是异常很犹豫。看了一些大牛的博客后。决定采用如下做法。
> 1. 对于错误码有语义时。返回错误码。比如类似find这样的函数，找到，找不到都是正常的。即大部分的二元语义。
> 2. 其它则使用异常。错误码有个不好用的地方在于，要一直传递。不太好用。


## 0.6 订阅发布和事务的实现
订阅发布机制实际上就是典型的生产者和消费者模式。实现起来也比较简单。
事务的实现主要是依赖一个队列。同时涉及事务回滚的问题。需要dirtykey的设置。主要按照Redis设计与实现部分实现。


> 1. subscribe 实现
> 2. publish 实现
> 3. unsubscribe 实现

### Topic/Channel
在redis里面，叫了Channel但是在Kafka中实际上是叫Topic的。其本质上是差不多。下面谈实现。
首先设计一个topic_name-topic的hash映射。每个topic存放的是connection的set。这样就完成了订阅结构的存取。然后在对应的命令表中实现
对应命令。


### 事务
事务实现起来也比较简单，就是不去立即执行命令，而是去用一个队列收集命令。EXEC后，才会一次性执行所有命令。
> 1. multi 实现，简单来说就是执行multi后，connection就被打了标记。之后的所有命令全部入队。
> 2. exec 实现, 就是将入队的命令依次实现，注意redis是不会回滚事务的。即使事务中的命令失败，也是依次执行。
> 3. watch 实现，按照redis设计与实现逻辑实现
> 4. unwatch 实现
> 5. discard 实现，清理标记。很简单。

### Base
在Base库中重新做了基于std::chrono库的Timestamp，目前时间精度是ms，完成了小根堆的定时器容器。

### 0.7 使用muduo
0.7 版本算是一个测试版本，采用了muduo实现0.6版本。仅仅是为了自己测试一些特性使用。因为muduo采用的是boost库。而我则尽量能地
使用C++17中的内容。

## 0.8 利用定时器队列完成过期key的设置
### 完成跳表。
完成跳表的编写。
1. zadd   O(logN)
2. zrange O(N)
3. zcard  O(1)
4. zrank  O(logN)
5. zscore O(1)
### TODO: 完成过期key的设置。
